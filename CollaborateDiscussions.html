<!DOCTYPE HTML>
<!--
	Forty by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Generic - Forty by HTML5 UP</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a href="index.html" class="logo"><strong>Forty</strong> <span>by HTML5 UP</span></a>
						<nav>
							<a href="#menu">Menu</a>
						</nav>
					</header>

				<!-- Menu -->
					<nav id="menu">
						<ul class="links">
						<li><a href="index.html">Home</a></li>
							<li><a href="AboutMe.html">About Me</a></li>
							<li><a href="Artefacts.html">About Me</a></li>
							<li><a href="LearningOutcomes.html">Learning Outcomes</a></li>
							<li><a href="actionplan.html">Professional Skills Matrix and Action Plan</a></li>
							
						</ul>
						<ul class="actions stacked">
							<li><a href="#" class="button primary fit">Get Started</a></li>
							<li><a href="#" class="button fit">Log In</a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main" class="alt">

						<!-- One -->
							<section id="one">
								<div class="inner">
									<header class="major">
										<h1>Collaborate Discussion 1: Factors that influence the reuseability of a piece of code </h1>
									</header>



									<h2>Initial Post</h2>
									<p>
      <p>Below is my prioritized list based on the factors identified by Padhy et al. (2018) that are influential to the reusability of a piece of object-oriented software:</p>

        <ol>
            <li>Knowledge requirements: I believe this should be top priority as knowledge can be reused across any project. Programmers need to understand design patterns and how to document correctly to ensure reusability of a piece of software.</li>
            <li>Modules in the Program: Breaking code down into components isolates functionality, making modules very easy to reuse.</li>
            <li>Documentation in the project: This is vital for reuse as in the article Laborde et al. (2022), lack of time for documentation can lead to serious issues of reuse later down the line. If one of their knowledgeable team members leaves the company, it makes it harder to reuse code as they may not know it exists or how it works.</li>
            <li>Architecture-driven approach: This acts as a blueprint of the software which makes it easier for developers to grasp the system, making it easier for reuse.</li>
            <li>Design Patterns: These provide standard solutions and are recognizable templates, which make it easier to identify what the code does and how to use it. As explained by Singh, Ianculescu, and Torje (2018), design patterns are general and reusable solutions that we can apply to common issues.</li>
            <li>An algorithm used in the program: Many developers will be aware of these algorithms so they will be able to identify and understand the code more easily for reuse.</li>
            <li>Test cases/test design: Test cases help influence reusability as when code is tested, it becomes reliable and will be trusted for further use of the code.</li>
            <li>Models in the project: The models help understand the system’s structure, making it easier to reuse.</li>
            <li>Requirement Analysis: Programmers can identify what is needed for the project and identify any patterns. If there are any patterns, they can create reusable components for other programs and customers. However, these are very specific to each piece of software.</li>
            <li>Service Contracts: By defining an interface, developers can create components for reuse, but once again, these can be quite specific.</li>
            <li>Used in the data project: If the data is structured easily and not complex, then it will promote reuse of the software. However, data differs depending on the type of software/module/customer.</li>
        </ol>

        <p>References:</p>
        <p>
            Padhy, N., Satapathy, S. & Singh, R.P. (2018) ‘State-of-the-art object-oriented metrics and its reusability: A decade review’, in: Satapathy, S., Bhateja, V. & Das, S. (eds) Smart computing and informatics: Proceedings of the First International Conference on SCI 2016. Singapore: Springer, pp. 431-441.<br><br>
            Laborde, P. et al. (2022) 'Reuse in component-based prototyping: an industrial experience report from 15 years of reuse,' Innovations in Systems and Software Engineering, 18(1), pp. 155–169. https://doi.org/10.1007/s11334-022-00456-4.<br><br>
            Singh, K., Ianculescu, A., and Torje, L.-P. (2018). Design Patterns and Best Practices in Java: A Comprehensive Guide to Building Smart and Reusable Code in Java. Birmingham: Packt Publishing Ltd.
        </p>
									<h2>Peer Responses</h2>
									<H3>First Response</H3>

									<p>Please see below response to Shraddha Gore.


Your work is structured very clearly and is easy to follow. I found your order of factors and your explanations to justify the prioritisation very insightful! Placing architecture-driven approach at the top does make a lot of sense as after further reflection, even if we have the best documentation it will not help if a robust architectural framework is not implemented.

I noticed that you have put knowledge requirements quite far down in your list whereas I have ranked it first. I understand your reasoning that it does not directly impact code reusability, and that you prioritised more immediate points first. However, my reasoning is that without the knowledge to follow an architecture-driven approach, we would not be able to put it into practice effectively. The difference in the order of priorities between our lists gave me an insight on how others view the importance of each factor for reuse.

I also placed service contracts as one of the lowest priorities for the same reason that these are quite specific and are not directly related to the reusability of code, making them less critical than other factors.

I really appreciate your insights and your reasonings have made me reflect on my own work and reconsider my prioritisation, which is great as your justifications are very effective.

Thank you!
</p>
									<h3>Second Response</h3>

									<p>
Response to Timothy Brayshaw



Thank you for sharing your insight in a clear, organised table format. I agree with your reasons to place service contracts lower on the list. Whilst service contracts are important for client relationships as they provide a clear framework for expectations, they do not contribute directly to code reuse.

I also agree that used in data should be lower in priority. Data structures vary from project to project and are often tailored to meet specific requirements, making them less helpful for reuse.

After reflecting on your top priority being requirement analysis and the reasoning behind this, I decided to look into this further and do some research. According to Bosch and Krueger (2004), they suggest that it is difficult to reuse components if it is not planned during the requirement specification stage. I now realise the importance of the requirement analysis for reuse.

I particularly liked the concluding paragraph which ties all the information together. It emphasises that the foundation for software reuse is established during the planning stage and summarises the main ideas behind your prioritisation. Your insights have gave me a better understanding of how these elements connect and impact software development as a whole.

References:

 Bosch, J. (2004) Software Reuse: Methods, Techniques, and Tools: 8th International Conference, ICSR 2004, Madrid, Spain, July 5-9, 2004. Proceedings. Berlin: Springer, p. 61.</p>
<h2> Summary Post</h2>

									<p> From the knowledge I have gained through posts from my peers and the content from Units 1 to 3, I now have a better understanding of the factors that influence code reusability and their respective roles.

I agree with Brayshaw (2024) who states that documentation, testing and service contracts support the reuse of code. He  emphasises that modules, design patterns and algorithms are more critical as they provide the ability to reuse code . This has helped me understand the logic in which he has prioritised his order.

Whilst trying to prioritise my list again I have come to the realisation that I would be prioritising based on sequence or direct reusability and not on the actual influence of code reusability. I am finding it difficult to prioritise based on the influence of code reusability because each factor plays a critical role and they are highly interconnected and interdependent. For example, modules are still dependent on knowledge requirements and an architectural structure. In contrast, if there are no modules in the program, the architectural approach will not work effectively.

Also some factors serves different purposes. For example, the requirement analysis identifies features which should be reusable, whilst the testing process focuses on ensuring that the module works for the current context and potential use.

To conclude, achieving code reusability relies on a combination of factors that work together. They all contribute in their own ways and are all important for the reuse of software.



References:


Brayshaw, T. (2024) Initial post. OOP October 2024. Forum post submitted to the University of Essex Online.</p>
									<h2> Tutor Feedback</h2>
									<p> Thank you for your contributions to the discussion forum. It’s fantastic to see the level of engagement and thoughtfulness in your posts, as well as the effort you’ve put into critically analysing and prioritising the factors influencing reusability in object-oriented software.

A key strength across the group is your ability to explore and justify your rankings. Many of you have considered the practical implications of each factor, showing how they might apply in real-world scenarios. This approach not only demonstrates your understanding of the topic but also highlights your ability to connect theory to practice, which is a crucial skill at this level.

It’s also great to see constructive peer engagement. Discussions that compare and contrast different perspectives help deepen understanding and encourage critical thinking. Building on others’ ideas, challenging assumptions, or providing alternative viewpoints are excellent ways to enhance these interactions and make the discussions even more enriching.

For future posts, I encourage everyone to focus on critical analysis and synthesis rather than just describing concepts. Use examples or evidence to support your points and explain how they influence your thinking. When responding to peers, aim to expand on their ideas or provide constructive feedback to add depth to the discussion.

</p>
									<h2>Reflection</h2>
									Engaging in this discussion has significantly enhanced my understanding of object-oriented programming (OOP), as it encouraged me to research each factor influencing code reusability in depth. This process not only deepened my knowledge of concepts like design patterns, architectural approaches, and documentation but also showed how these factors work together to make software more reusable and efficient. By exploring each factor thoroughly, I developed a stronger appreciation for their practical applications and how they collectively contribute to robust OOP practices.

			<header class="major">
										<h1>Collaborate Discussion 2: OO Design for IoT </h1>
									</header>



									<h2>Initial Post</h2>
									<p>
Designing metamodels offers several key strengths and weaknesses. According to Fortino et al. (2015), metamodels ensure that components clearly understand their behaviours and interactions, reducing confusion and facilitating smooth communication by abstracting key entities and their relationships. 

Fortino et al. (2015) attempt to standardise metamodels but leave room for adaptability, particularly in areas such as security, which can be added later. However, adaptability remains a significant challenge, as Bashir et al. (2020) highlight, noting that each metamodel requires real-world validation, introducing additional costs and complexity. Real-world validation is essential to ensure the metamodel’s effectiveness and capture all relevant elements across diverse scenarios. Saleh (2023) further supports this, emphasising that while model comparisons can identify some gaps, key elements may still be overlooked depending on the context.

Fortino et al. (2015) acknowledge that metamodels enhance communication, which can, in turn, improve system uptime. Shah (2023) reinforces this point, noting that system uptime could improve by 10% to 15%. However, these improvements are often accompanied by trade-offs, such as increased maintenance complexity and additional costs, including redundancy. Balancing these trade-offs is crucial to ensure system reliability and efficiency, especially in IoT environments

Ultimately, while metamodels face challenges such as validation and maintenance complexity, they offer substantial advantages in system design, particularly when tailored and validated appropriately. Bashir et al. (2020) also highlight that metamodels support future users, making them beneficial not only for current system performance but also for future development and applications.


A metamodel for a humanoid robotHumanoid Robot Metamodel



<p>References</p>

Bashir, M.R. et al., 2020. Big Data Management and Analytics Metamodel for IoT-Enabled Smart Buildings. IEEE Access, [e-journal] 8, pp.169740–169758. Available at: https://doi.org/10.1109/ACCESS.2020.3024066 [Accessed 16 Dec. 2024]

Fortino, G., Guerrieri, A., Russo, W. & Savaglio, C. (2015). Towards a Development Methodology for Smart Object-Oriented IoT Systems: A Metamodel Approach. 2015 IEEE International Conference on Systems, Man, and Cybernetics. 1297-1302. DOI: 10.1109/SMC.2015.231. 

Saleh, M. et al., 2023. A Metamodeling Approach for IoT Forensic Investigation. Electronics, 12(3). Available at: https://doi.org/10.3390/electronics12030524 [Accessed 16 Dec. 2024]..

Shah, Q. A. et al. (2023) A Meta Modeling-Based Interoperability and Integration Testing Platform for IoT Systems. Sensors, 23(21). Available at: https://doi.org/10.3390/s23218730 (Accessed: 16 December 2024). 

									<h2>Peer Response</h2>
									
Response to Todd Edge

Hi Todd,

Your initial post was an interesting read. I particularly liked the metamodel you created—how did you go about designing it? I used Lucidchart for mine, but I couldn’t find a design similar to the one shown in Figure 6, so I ended up using a class diagram instead.

I believe you have done a great job highlighting the strengths and weaknesses of metamodels in IoT design. While your post focuses on Fortino et al. (2015), I approached the topic more generally, referencing Fortino et al. (2015) as part of my analysis. I think your post could benefit from expanding to include a broader perspective on metamodels in general, which might offer additional insights.

I also found your use of Sharma & Bawa (2022) and Meneghello et al. (2019) to critique Fortino et al.'s model particularly interesting, especially regarding the security aspects, given the critical importance of this issue in IoT development.

Overall, I really enjoyed reading your post. It’s clear and well-referenced, and it inspired me to reflect more on how metamodels address challenges like security. 


Edge, T., 2024. Response to discussion topic: OO Design for IoT, 14 December. [Accessed 23 December 2024].


									<h2>Reflection</h2>
Reflecting on my response to Todd, I realise how helpful the feedback process has been in improving my understanding. By discussing Todd's design and asking about his approach, I was able to clarify my own thoughts and recognise areas where I could have expanded. For example, while I touched on security in metamodels, I now see I could have delved deeper into this aspect. Additionally, Todd's use of Lucidchart made me reconsider my own choice of tools for metamodel design. Overall, the feedback exchange helped me see the importance of looking at the broader picture and highlighted areas where I could enhance my own analysis.
								</div>
							</section>

					</div>

				<!-- Contact -->
					<section id="contact">
						<div class="inner">
							<section>
								<form method="post" action="#">
									<div class="fields">
										<div class="field half">
											<label for="name">Name</label>
											<input type="text" name="name" id="name" />
										</div>
										<div class="field half">
											<label for="email">Email</label>
											<input type="text" name="email" id="email" />
										</div>
										<div class="field">
											<label for="message">Message</label>
											<textarea name="message" id="message" rows="6"></textarea>
										</div>
									</div>
									<ul class="actions">
										<li><input type="submit" value="Send Message" class="primary" /></li>
										<li><input type="reset" value="Clear" /></li>
									</ul>
								</form>
							</section>
							<section class="split">
								<section>
									<div class="contact-method">
										<span class="icon solid alt fa-envelope"></span>
										<h3>Email</h3>
										<a href="#">information@untitled.tld</a>
									</div>
								</section>
								<section>
									<div class="contact-method">
										<span class="icon solid alt fa-phone"></span>
										<h3>Phone</h3>
										<span>(000) 000-0000 x12387</span>
									</div>
								</section>
								<section>
									<div class="contact-method">
										<span class="icon solid alt fa-home"></span>
										<h3>Address</h3>
										<span>1234 Somewhere Road #5432<br />
										Nashville, TN 00000<br />
										United States of America</span>
									</div>
								</section>
							</section>
						</div>
					</section>

				<!-- Footer -->
					<footer id="footer">
						<div class="inner">
							<ul class="icons">
								<li><a href="#" class="icon brands alt fa-twitter"><span class="label">Twitter</span></a></li>
								<li><a href="#" class="icon brands alt fa-facebook-f"><span class="label">Facebook</span></a></li>
								<li><a href="#" class="icon brands alt fa-instagram"><span class="label">Instagram</span></a></li>
								<li><a href="#" class="icon brands alt fa-github"><span class="label">GitHub</span></a></li>
								<li><a href="#" class="icon brands alt fa-linkedin-in"><span class="label">LinkedIn</span></a></li>
							</ul>
							<ul class="copyright">
								<li>&copy; Untitled</li><li>Design: <a href="https://html5up.net">HTML5 UP</a></li>
							</ul>
						</div>
					</footer>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
